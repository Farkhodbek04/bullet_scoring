<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Target Scoring Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --maxw: 640px; }
    body{font-family:Arial,Helvetica,sans-serif;margin:20px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    select,button{padding:6px 10px;font-size:14px}
    .status{margin-left:8px;font-weight:bold}
    .status.err{color:#c00}
    .status.ok{color:#0a0}
    .score{margin-top:10px;font-size:16px}
    .preview-wrap{margin-top:12px;max-width:var(--maxw)}
    img#preview{display:block;width:100%;border:1px solid #333}
    .badge{display:inline-block;padding:2px 6px;border-radius:6px;background:#eee;font-size:12px;margin-left:6px}
    .badge.ok{background:#d7ffd7;border:1px solid #8ac78a}
    .badge.off{background:#ffe0e0;border:1px solid #e9a1a1}
    .pill{padding:2px 8px;border-radius:999px;border:1px solid #999;font-size:12px}
    .pill.on{background:#d7ffd7;border-color:#8ac78a}
    .pill.off{background:#eee}
    .meta{font-size:12px;color:#444;margin-top:6px}
    .muted{opacity:.8}
  </style>
</head>
<body>
  <h1>Target Scoring Dashboard</h1>
  <div id="root"></div>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <script>
    (function () {
      const { useEffect, useMemo, useRef, useState } = React;

      const LS_KEY = "target-dashboard-state-v2";
      const loadLocal = () => { try { return JSON.parse(localStorage.getItem(LS_KEY) || "{}"); } catch { return {}; } };
      const saveLocal = (data) => { try { localStorage.setItem(LS_KEY, JSON.stringify(data)); } catch {} };

      function useStableWs(url) {
        const [ready, setReady] = useState(false);
        const [lastMessage, setLastMessage] = useState(null);
        const wsRef = useRef(null);
        const timerRef = useRef(null);

        const connect = () => {
          try {
            const ws = new WebSocket(url);
            wsRef.current = ws;
            ws.onopen = () => setReady(true);
            ws.onclose = () => {
              setReady(false);
              clearTimeout(timerRef.current);
              timerRef.current = setTimeout(connect, 1500);
            };
            ws.onerror = () => { try { ws.close(); } catch (e) {} };
            ws.onmessage = (ev) => { try { setLastMessage(JSON.parse(ev.data)); } catch {} };
          } catch (e) {
            setReady(false);
            clearTimeout(timerRef.current);
            timerRef.current = setTimeout(connect, 2000);
          }
        };

        useEffect(() => {
          connect();
          return () => {
            clearTimeout(timerRef.current);
            if (wsRef.current) try { wsRef.current.close(); } catch(e){}
          };
        }, [url]);

        return { ready, lastMessage };
      }

      function App() {
        // Initialize from localStorage for instant restore
        const init = loadLocal();

        const [cameras, setCameras] = useState(init.cameras || []);
        const [active, setActive] = useState(new Set(init.active || []));
        const [currentCam, setCurrentCam] = useState(init.currentCam || null);
        const [statusMsg, setStatusMsg] = useState("");
        const [imgSrc, setImgSrc] = useState(init.imgSrc || "");
        const [score, setScore] = useState(init.score ?? "N/A");
        const [pointsMap, setPointsMap] = useState(init.pointsMap || {}); // { cam_id: [points...] }
        const [startBusy, setStartBusy] = useState(false);
        const [stopBusy, setStopBusy] = useState(false);

        // Persist to localStorage
        useEffect(() => {
          saveLocal({
            cameras,
            active: Array.from(active),
            currentCam,
            score,
            imgSrc,
            pointsMap
          });
        }, [cameras, active, currentCam, score, imgSrc, pointsMap]);

        const wsUrl = useMemo(() => {
          const proto = location.protocol === 'https:' ? 'wss' : 'ws';
          return proto + '://' + location.host + '/ws/client';
        }, []);
        const { ready: wsReady, lastMessage } = useStableWs(wsUrl);

        // Derived UI states
        const isActive = currentCam ? active.has(currentCam) : false;
        const canStart = !!(cameras.length && (currentCam || cameras[0])) && !startBusy && !stopBusy && !isActive;
        const canStop  = !!currentCam && !stopBusy && isActive;
        const detections = (currentCam && pointsMap[currentCam]) ? pointsMap[currentCam].length : 0;

        // Handle server messages
        useEffect(() => {
          if (!lastMessage) return;

          if (lastMessage.action === "snapshot") {
            const list = Array.isArray(lastMessage.cameras) ? lastMessage.cameras : [];
            setCameras(list);

            const act = new Set(Array.isArray(lastMessage.active) ? lastMessage.active : []);
            setActive(act);

            const lr = lastMessage.last_results || {};
            // Build a points map from snapshot
            const pm = {};
            for (const k in lr) {
              pm[k] = lr[k].points || [];
            }
            setPointsMap(pm);

            // If currentCam has snapshot data, hydrate it; else pick default
            if (currentCam && lr[currentCam]) {
              setScore(lr[currentCam].score ?? "N/A");
              setImgSrc(lr[currentCam].image ? "data:image/jpeg;base64," + lr[currentCam].image : "");
            } else if (!currentCam && list.length > 0) {
              const firstActive = list.find(c => act.has(c));
              const fallback = firstActive || list[0];
              setCurrentCam(fallback);
              const data = lr[fallback] || {};
              setScore(data.score ?? "N/A");
              setImgSrc(data.image ? "data:image/jpeg;base64," + data.image : "");
            } else if (list.length === 0) {
              setStatusMsg("Pi offline / no cameras.");
              setCurrentCam(null); setScore("N/A"); setImgSrc("");
            } else {
              setStatusMsg("");
            }
          }

          if (lastMessage.action === "result") {
            const cam = lastMessage.cam_id;
            // update per-cam last points
            setPointsMap(prev => ({ ...prev, [cam]: lastMessage.points || [] }));
            // if it's the currently selected cam, show it immediately
            if (cam && cam === currentCam) {
              setScore(lastMessage.score ?? "N/A");
              if (lastMessage.image) setImgSrc("data:image/jpeg;base64," + lastMessage.image);
            }
          }
        }, [lastMessage, currentCam]);

        // Camera switch handler â€” loads last known snapshot/result
        const onChangeCam = (e) => {
          const v = e.target.value || null;
          setCurrentCam(v);
          if (!v) {
            setScore("N/A"); setImgSrc("");
            return;
          }
          const s = loadLocal(); // best-effort hydrate from last snapshot in storage
          const lr = (s && s.last_results) || null;
          if (lr && lr[v]) {
            setScore(lr[v].score ?? "N/A");
            setImgSrc(lr[v].image ? "data:image/jpeg;base64," + lr[v].image : "");
          } else {
            // Fall back to pointsMap only; keep score (unknown) and clear image
            setImgSrc("");
            setScore("N/A");
          }
          setStatusMsg("");
        };

        const startStream = async () => {
          const cam = currentCam || cameras[0];
          if (!cam || !canStart) return;
          setStartBusy(true);
          setStatusMsg(`Starting ${cam}...`);
          try {
            const r = await fetch(`/start/${encodeURIComponent(cam)}`);
            const j = await r.json();
            if (j.status === "ok") {
              setStatusMsg(`Streaming ${cam}`);
              setActive(prev => new Set(prev).add(cam));
            } else {
              setStatusMsg(j.detail || "Error starting");
            }
          } catch {
            setStatusMsg("Error contacting server.");
          } finally {
            setStartBusy(false);
          }
        };

        const stopStream = async () => {
          if (!currentCam || !canStop) return;
          const cam = currentCam;
          setStopBusy(true);
          try {
            const r = await fetch(`/stop/${encodeURIComponent(cam)}`);
            const j = await r.json();
            if (j.status === "ok") {
              setStatusMsg(`Stopped ${cam}`);
              setActive(prev => { const n = new Set(prev); n.delete(cam); return n; });
            } else {
              setStatusMsg(j.detail || "Error stopping");
            }
          } catch {
            setStatusMsg("Error contacting server.");
          } finally {
            setStopBusy(false);
          }
          // Keep last image & score visible
        };

        return React.createElement(
          "div",
          null,
          React.createElement(
            "div",
            { className: "row" },
            React.createElement("div", null, "Camera: "),
            React.createElement(
              "select",
              {
                id: "cam",
                value: currentCam || "",
                onChange: onChangeCam,
                disabled: cameras.length === 0 || startBusy || stopBusy
              },
              cameras.length === 0
                ? React.createElement("option", { value: "" }, "-- No cameras --")
                : cameras.map((c) => React.createElement("option", { key: c, value: c }, c))
            ),
            React.createElement(
              "button",
              { id: "start", onClick: startStream, disabled: !canStart },
              startBusy ? "Starting..." : "Start"
            ),
            React.createElement(
              "button",
              { id: "stop", onClick: stopStream, disabled: !canStop },
              stopBusy ? "Stopping..." : "Stop"
            ),
            React.createElement(
              "span",
              { className: "badge " + (wsReady ? "ok" : "off") },
              wsReady ? "WS connected" : "WS offline"
            ),
            React.createElement(
              "span",
              { id: "status", className: "status " + (statusMsg ? "err" : "") },
              statusMsg
            ),
            cameras.length > 0 && React.createElement(
              "span",
              { className: "pill " + (isActive ? "on" : "off") },
              currentCam ? (isActive ? "active" : "idle") : "idle"
            )
          ),

          React.createElement(
            "div",
            { className: "meta" },
            currentCam ? `Detections on ${currentCam}: ${detections}` : "No camera selected"
          ),

          React.createElement(
            "div",
            { className: "score" },
            "Score: ",
            React.createElement("span", { id: "score" }, String(score))
          ),

          React.createElement(
            "div",
            { className: "preview-wrap" },
            React.createElement("img", { id: "preview", alt: "preview", src: imgSrc })
          ),

          React.createElement(
            "div",
            { className: "meta muted" },
            "Tip: switching cameras shows the last known frame & score for that camera."
          )
        );
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(React.createElement(App));
    })();
  </script>
</body>
</html>
